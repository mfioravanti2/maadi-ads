# Author : Mark Fioravanti (mfioravanti1994@my.fit.edu)
#          Florida Institute of Technology
# Course : CSE5400 Special Topics - Algebraic Data Structures
# Date   : 10/01/2013
# File   : builder.rb
#
# Summary: The build will take an XML configuration file and use the options
#          to build the procedures for an expert.

require 'rubygems'
require 'nokogiri'

require_relative '../generic/generic'
require_relative '../procedure/procedure'
require_relative '../helpers'
require_relative 'builder/phase'
require_relative 'model'

module Maadi
  module Expert
    module Builder
    class Builder < Maadi::Generic::Generic
      # type (String) is a convenient human readable label.
      def initialize
        super('Builder')

        @tests = Hash.new

        @options['BUILD-NAME'] = ''
        @notes['BUILD-NAME'] = 'XML file which contains the build script'
      end

      # extract a hash with information about the tests located within the file
      # specified.
      # return (Hash) key = test name, value = (Hash) { type = ###, source = ### }
      def self.extract_tests(file)
        tests = Hash.new

        if File.exists?( "../lib/custom/expert/builders/#{file}.xml" )
          xml_file = File.open( "../lib/custom/expert/builders/#{file}.xml" )
          xml_doc = Nokogiri::XML( xml_file )
          xml_file.close

          nodes = xml_doc.xpath('//tests/test')
          nodes.each do |node|
            tests[ node['name'] ] = { 'type' => 'internal', 'source' => file }

            if node.attributes.keys.include?('type') and node.attributes.keys.include?( 'source' )
              tests[ node['name'] ]['type'] = node['type']
              tests[ node['name'] ]['source'] = node['source']
            end
          end
        end

        return tests
      end

      # extract an XML node from a test file, if the node type is 'external', the function
      # will attempt to extract the file from the location listed in the 'source' attribute
      # return (Nokogiri::Node)
      def self.extract_test(test,file)
        node = nil

        if File.exists?( "../lib/custom/expert/builders/#{file}.xml" )
          xml_file = File.open( "../lib/custom/expert/builders/#{file}.xml" )
          xml_doc = Nokogiri::XML( xml_file )
          xml_file.close

          node = xml_doc.at("//tests/test[@name='#{test}']")
          if node != nil
            if node.attributes.keys.include?('type') and node.attributes.keys.include?( 'source' )
              if node['type'].downcase == 'external' and node['source'] != file
                return extract_test( test, node['source'] )
              end
            end
          end
        end

        return node
      end

      # prepare will setup the execution environment.  No tests will be executed but all required
      # resources and services will be prepared to execution.
      # return (bool) true if all of the components are read.
      def prepare
        if File.exists?( "../lib/custom/expert/builders/#{@options['BUILD-NAME']}.xml" )
          Maadi::post_message(:More, "Builder (#{@type}) loading files")

          items = Builder.extract_tests( @options['BUILD-NAME'] )
          items.each do |key, value|
            node = Builder.extract_test( key, value['source'] )
            if node != nil
              @tests[ key ] = node
            end
          end
        else
          Maadi::post_message(:Warn, "Builder (#{@type}) unable to access files")
          return false
        end

        Maadi::post_message(:More, "Builder (#{@type}) is ready")
        super
      end

      # provide a list of possible tests
      # return (Array of Strings) with each element representing the name of
      # a test that this domain expert can generate
      def tests
        return @tests.keys
      end

      # create a specific test procedure that can be executed against an application.
      # test (String) name of a test (must be on the list generated by the tests function)
      # parameters (Array of Parameters) array of selected parameters for the desired test
      # return (Procedure) return complete test procedure that is ready to be executed.
      def procedure( test, procedure, expert, model )
        unless @tests.keys.include?( test )
          Maadi::post_message(:Warn, "Builder (#{@type}) unable to find test #{test}")
          return procedure
        end

        node = @tests[test].at('phases')
        if node != nil
          phase = @tests[test].at('phases')['default']
          if procedure != nil
            phase = procedure.id
          end
          phase_node = @tests[test].at("phases/phase[@name='#{phase}']")
          if phase_node != nil
            #puts "Building test with phase #{phase_node['name']}"
            phase = Maadi::Expert::Builder::Phase.new( phase_node, expert, model )
            procedure = phase.process( procedure, expert, model )
          end
        else
          Maadi::post_message(:Warn, "Builder (#{@type}) unable to find test #{test} templates")
        end

        return procedure
      end

      # teardown the object if any database connections, files, etc. are open.
      def teardown
        Maadi::post_message(:Less, "Builder (#{@type}) is NO longer ready")
        super
      end

      def self.is_builder?( builder )
        if builder != nil
          if builder.is_a?( Maadi::Expert::Builder )
            return true
          end
        end

        return false
      end
    end
      end
  end
end